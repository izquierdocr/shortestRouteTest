#include <iostream>
#include <fstream>	//files
#include <vector>
#include <algorithm>	//sort
//#include <stdlib.h>	//rand
#include <sstream>	//ostringstream
#include <iomanip>	//setfill, setw

using namespace std;

typedef vector<float> floatVector;
typedef vector<floatVector> MatVector;


struct locationNode {
  int ID;
  float objectProbability;
  float priority;
};

float DISTANCES_MEAN;
float DISTANCES_SIGMA;
float PROBABILITY_MEAN;
float PROBABILITY_SIGMA;
int MAX_MAPS;
string mapDataBase;


float optimalExpectedDistance=0;
vector<locationNode> optimalRoute;
float worstExpectedDistance=0;
vector<locationNode> worstRoute;

void loadMapData(int numNodes, int numMap, string mapType, MatVector &distancesTable) {
  string dataFileName;
  
  ostringstream strNodes;
  strNodes << setfill('0') << setw(2) << numNodes;
  ostringstream strNumMap;
  strNumMap << setfill('0') << setw(3) << numMap;
  dataFileName = mapDataBase + "map" + mapType + strNodes.str() + strNumMap.str() + ".txt";
  cout << "Loading data from " << dataFileName << endl;
  ifstream fileStream(dataFileName.c_str());

  string mapFileName;
  fileStream >> mapFileName;
  //cout << "Map image file: " << mapFileName << endl;
  
  int roomListSize;
  fileStream >> roomListSize;
  //cout << "Rooms: " << roomListSize << endl;
  
  for (int i=0; i<roomListSize; i++) {
    int x,y;
    //fileStream >> roomList[i].roomName << endl;
    fileStream >> x >> y;
    //cout << "X: " << x << "   Y: " << y << endl;
  }
  for (int i=0; i<roomListSize; i++) {
    for (int j=0; j<roomListSize; j++) {
      fileStream >> distancesTable[i][j];
      //cout << distancesTable[i][j] << " ";
    }
    //cout << endl;
  }
  fileStream.close();
}


void buildEnvironment(vector<locationNode> &locationList, MatVector &distancesTable, int numNodes) {
  float totalProbability=0;
    for (int i=0; i<numNodes; i++) {
      locationNode location;
      location.ID=i;
      location.objectProbability=PROBABILITY_MEAN + PROBABILITY_SIGMA * (float(rand()) / RAND_MAX-0.5);		//1.0/numNodes;
      cout << location.objectProbability << endl;
      totalProbability+=location.objectProbability;
      location.priority=0;
      locationList.push_back(location);
    }
    for (int i=0; i<locationList.size(); i++) {
      locationList[i].objectProbability=locationList[i].objectProbability/totalProbability;
    }
    
    floatVector rowMat;
    rowMat.assign(numNodes,0);
    for (int i=0; i<numNodes; i++) {
      distancesTable.push_back(rowMat);
    }
    
    //Generate distances randomly
    for (int i=1; i<numNodes; i++) {
      for (int j=0; j<i; j++) {
	distancesTable[i][j]= DISTANCES_MEAN + DISTANCES_SIGMA * (float(rand()) / RAND_MAX -0.5);
	distancesTable[j][i]=distancesTable[i][j];
      }
    }
    //Load distances from files
    int numMap = MAX_MAPS*(float(rand()) / RAND_MAX)+1;
    string mapType = "H";	//Tipy: House(H), Office (O)
    loadMapData(numNodes, numMap, mapType, distancesTable);
   
   //Print node data
    cout << "Locations" << endl;
    for (int i=0; i<locationList.size(); i++) {
      cout << locationList[i].ID << ", ";
      cout << locationList[i].priority  << ", ";
      cout << locationList[i].objectProbability << endl;
    }
    
    //Print distances data
    cout << "Distances table" << endl;
    for (int i=0; i<numNodes; i++) {
      for (int j=0; j<numNodes; j++) {
	cout << distancesTable[i][j] << "   ";
      }
      cout << endl;
    }
    
}

void showLocationOrder(vector<locationNode> locationList, string sortingMethod) {
  cout << "Locations ordered by " << sortingMethod << endl;
  for (int i=0; i<locationList.size(); i++) {
    cout << locationList[i].ID << ", ";
    //cout << locationList[i].priority  << ", ";
    //cout << locationList[i].objectProbability << endl;
  }
  cout << endl;
}

bool wayToSortLocations(locationNode i, locationNode j) {
  return i.priority > j.priority;
}

void generateRouteMostProbable(vector<locationNode> &locationList, MatVector distancesTable, int startingNode) {
  for (int i=0; i<locationList.size(); i++) {
    locationList[i].priority = locationList[i].objectProbability;
    locationList[startingNode].priority += locationList[i].priority;	//The highest priority
  }
  sort(locationList.begin(), locationList.end(), wayToSortLocations);
}

void generateRouteClosestFixed(vector<locationNode> &locationList, MatVector distancesTable, int startingNode) {
  for (int i=0; i<locationList.size(); i++) {
    locationList[i].priority = 1/distancesTable[startingNode][i];
    locationList[startingNode].priority += locationList[i].priority;	//The highest priority
  }
  sort(locationList.begin(), locationList.end(), wayToSortLocations);
}

void generateRouteClosest(vector<locationNode> &locationList, MatVector distancesTable, int startingNode) {
  //The closest node from the previous. Not from the origin
  vector<locationNode> locationListSorted;
  locationListSorted.push_back(locationList[startingNode]);
  locationList.erase(locationList.begin()+startingNode);
  int nextLocation=startingNode;
  int totalLocations=locationList.size();
  for (int i=0; i<totalLocations; i++) {
    float nextLocationValue=0;
    for (int j=0; j<locationList.size(); j++) {
      float locationValue = 1/distancesTable[startingNode][locationList[j].ID];
      if (locationValue>nextLocationValue) {
	nextLocationValue=locationValue;
	nextLocation=j;
      }
    }
    startingNode=locationList[nextLocation].ID;
    locationListSorted.push_back(locationList[nextLocation]);
    locationList.erase(locationList.begin()+nextLocation);
  }
  locationList=locationListSorted;
}

void generateRouteRandom(vector<locationNode> &locationList, MatVector distancesTable, int startingNode) {
  for (int i=0; i<locationList.size(); i++) {
    locationList[i].priority = float(rand()) / RAND_MAX;
    locationList[startingNode].priority += locationList[i].priority;	//The highest priority
  }
  sort(locationList.begin(), locationList.end(), wayToSortLocations);
}

void generateRouteExpectedTimeFixed(vector<locationNode> &locationList, MatVector distancesTable, int startingNode) {
  for (int i=0; i<locationList.size(); i++) {
    locationList[i].priority = locationList[i].objectProbability/distancesTable[startingNode][i];
    locationList[startingNode].priority += locationList[i].priority;	//The highest priority
  }
  sort(locationList.begin(), locationList.end(), wayToSortLocations);
}

void generateRouteExpectedTimeVariable(vector<locationNode> &locationList, MatVector distancesTable, int startingNode) {
  vector<locationNode> locationListSorted;
  locationListSorted.push_back(locationList[startingNode]);
  locationList.erase(locationList.begin()+startingNode);
  int nextLocation=startingNode;
  int totalLocations=locationList.size();
  for (int i=0; i<totalLocations; i++) {
    float nextLocationValue=0;
    for (int j=0; j<locationList.size(); j++) {
      float locationValue = locationList[j].objectProbability/distancesTable[startingNode][locationList[j].ID];
      if (locationValue>nextLocationValue) {
	nextLocationValue=locationValue;
	nextLocation=j;
      }
    }
    startingNode=locationList[nextLocation].ID;
    locationListSorted.push_back(locationList[nextLocation]);
    locationList.erase(locationList.begin()+nextLocation);
  }
  locationList=locationListSorted;
/*
  }
  
      locationList[i].priority = locationList[i].objectProbability/distancesTable[startingNode][i];
    locationList[startingNode].priority += locationList[i].priority;	//The highest priority
  locationList[startingNode].priority=locationList.size();
  sort(locationList.begin(), locationList.end(), wayToSortLocations);
  */
}

void makeRoute(MatVector distancesTable, int node, vector<locationNode> locationList,vector<locationNode> listSorted) {
  if (locationList.size()>1) {
    listSorted.push_back(locationList[node]);
    locationList.erase(locationList.begin()+node);
    for (int i=0; i<locationList.size(); i++) {
      makeRoute(distancesTable, i, locationList, listSorted);
    }
  }
  else {
    listSorted.push_back(locationList[node]);
    float accumulatedDistance=0;
    float expectedDistance=0;
    for (int i=0; i<listSorted.size()-1; i++) {
      accumulatedDistance+=distancesTable[listSorted[i].ID][listSorted[i+1].ID];
      expectedDistance+=accumulatedDistance*listSorted[i+1].objectProbability;
    }
    if (expectedDistance<optimalExpectedDistance) {
      optimalExpectedDistance=expectedDistance;
      optimalRoute=listSorted;
    }
    if (expectedDistance>worstExpectedDistance) {
      worstExpectedDistance=expectedDistance;
      worstRoute=listSorted;
    }
  }
}

void generateRouteOptimalAndWorst(vector<locationNode> &locationListOptimal, vector<locationNode> &locationListWorst, MatVector distancesTable, int startingNode) {
  vector<locationNode> listSorted;
  
  makeRoute(distancesTable,startingNode,locationListOptimal,listSorted);
  locationListOptimal=optimalRoute;
  locationListWorst=worstRoute;
  return;
}
  
void determineObjectPosition(vector<locationNode> locationList, int &objectPosition) {
  float weightedProbability = float(rand()) / RAND_MAX;
  float accumulatedProbability=0.0;
  int indexLocationObject=0;
  
  while (weightedProbability>accumulatedProbability+locationList[indexLocationObject].objectProbability) {
    accumulatedProbability=accumulatedProbability+locationList[indexLocationObject].objectProbability;
    indexLocationObject++;
  }
  objectPosition=locationList[indexLocationObject].ID;
}

void evaluateRoute(vector<locationNode> locationList, MatVector distancesTable, int objectPosition, int &rooms, float &distance) {
  rooms=1;
  distance=0;
  for (int i=0; i<locationList.size()-1 && locationList[i].ID!=objectPosition; i++) {
    distance+=distancesTable[locationList[i].ID][locationList[i+1].ID];
    rooms++;
  }
}

int main(int argc, char **argv) {
  
    vector<locationNode> locationList;
    MatVector distancesTable;
    
    char outputNameFile[255]="experiments001.txt";
    mapDataBase="mapsDB/";
    DISTANCES_MEAN=100.0;
    DISTANCES_SIGMA=100.0;
    PROBABILITY_MEAN=0.5;
    PROBABILITY_SIGMA=1.0;
    MAX_MAPS=1; //Maps for category (rooms)
    int numNodes=5;
    optimalExpectedDistance=DISTANCES_MEAN*DISTANCES_SIGMA*numNodes;
    int startingNode=0;
    int numRepetitions=1000;
    
    
    buildEnvironment(locationList, distancesTable, numNodes);
    
    cout << endl << "Building strategies..." << endl;
    vector<locationNode> locationListMostProbable, locationListClosest, locationListRandom, locationListExpectedTimeFixed, locationListExpectedTimeVariable, locationListOptimal, locationListWorst;
    locationListMostProbable=locationList; locationListClosest=locationList; locationListRandom=locationList; locationListExpectedTimeFixed=locationList; locationListExpectedTimeVariable=locationList; locationListOptimal=locationList; locationListWorst=locationList;
    
    generateRouteOptimalAndWorst(locationListOptimal, locationListWorst, distancesTable, startingNode);
    showLocationOrder(locationListOptimal,"Optimal");
    showLocationOrder(locationListWorst,"Worst");
    generateRouteMostProbable(locationListMostProbable, distancesTable, startingNode);
    showLocationOrder(locationListMostProbable,"Most Probable");
    generateRouteClosest(locationListClosest, distancesTable, startingNode);
    showLocationOrder(locationListClosest,"Closest");
    generateRouteRandom(locationListRandom, distancesTable, startingNode);
    showLocationOrder(locationListRandom,"Random");
    generateRouteExpectedTimeFixed(locationListExpectedTimeFixed, distancesTable, startingNode);
    showLocationOrder(locationListExpectedTimeFixed,"Expected Time Fixed");
    generateRouteExpectedTimeVariable(locationListExpectedTimeVariable, distancesTable, startingNode);
    showLocationOrder(locationListExpectedTimeVariable,"Expected Time Variable");
    
    ofstream fileStream(outputNameFile);
    fileStream << "Experiment,System Time,Object at Room,";
    fileStream << "Rooms Explored (Optimal),Traveled Distance (Optimal),";
    fileStream << "Rooms Explored (Worst),Traveled Distance (Worst),";
    fileStream << "Rooms Explored (Most Probable),Traveled Distance (Most Probable),";
    fileStream << "Rooms Explored (Closest),Traveled Distance (Closest),";
    fileStream << "Rooms Explored (Random),Traveled Distance (Random),";
    fileStream << "Rooms Explored (ExpectedTimeFixed),Traveled Distance (ExpectedTimeFixed),";
    fileStream << "Rooms Explored (ExpectedTimeVariable),Traveled Distance (ExpectedTimeVariable)";
    fileStream << endl;
    fileStream.close();
    
    //getchar();
    cout << endl << "Begin of test!" << endl;
    for (int repetition=0; repetition<numRepetitions; repetition++) {
      
      cout << ".";
      //cout << "Repetition " << repetition << "  ";

      int objectPosition=0;
      determineObjectPosition(locationList, objectPosition);
      
      //cout << "Object in room " << objectPosition << endl;
      
      fileStream.open(outputNameFile, ios::app);
      fileStream << repetition << ",";
      fileStream << time(NULL) << ",";
      fileStream << objectPosition << ",";
      
      int rooms;
      float distance;
      evaluateRoute(locationListOptimal, distancesTable, objectPosition, rooms, distance);
      fileStream << rooms << "," << distance << ",";
      evaluateRoute(locationListWorst, distancesTable, objectPosition, rooms, distance);
      fileStream << rooms << "," << distance << ",";
      evaluateRoute(locationListMostProbable, distancesTable, objectPosition, rooms, distance);
      fileStream << rooms << "," << distance << ",";
      evaluateRoute(locationListClosest, distancesTable, objectPosition, rooms, distance);
      fileStream << rooms << "," << distance << ",";
      evaluateRoute(locationListRandom, distancesTable, objectPosition, rooms, distance);
      fileStream << rooms << "," << distance << ",";
      evaluateRoute(locationListExpectedTimeFixed, distancesTable, objectPosition, rooms, distance);
      fileStream << rooms << "," << distance << ",";
      evaluateRoute(locationListExpectedTimeVariable, distancesTable, objectPosition, rooms, distance);
      fileStream << rooms << "," << distance;
      
      fileStream << endl;
      fileStream.close();
    }

    cout << endl << "End of test!" << endl;
    return 0;
}
